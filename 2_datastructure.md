# 01. 배열 / 리스트
```
배열과 리스트 모두 선형 자료 구조에 속한다. 선형자료구조는 데이터가 연속적으로 연결되어있는 모양으로 구성 되어있으며, 순차적으로 나열시킨 형태를 말한다.
```
## 배열
<img src="img/array.jpg" />

### 배열이란?
* 연속적인 기억공간에 배정하며 각 요소들은 인덱스/값쌍으로 되어있어 인덱스로 값을 가져올 수 있다.

### 배열의 특징
* 가장 simple한 한자료구조이다 
* 인덱스로 접근할수 있다.
* 접근속도가 빠르다.
* 기억장소를 연속으로 배정받아 기억장소 이용 효율은 가장 좋다.
* 자료의 갯수가 n개일때 삽입시 평균 이동 횟수는 O(n), n+1/2, 삭제시 평균이동 횟수는 O(n), n-1/2, 조회시 O(1)
* 데이터 조희는 빠르지만 삽입, 삭제시 자료의 이동이 필요하기때무네 작업이 번거롭다.

### 실습
1. 배열하나를 선언하라
2. 임의의 숫자를 배열 10개를 넣어라
3. 배열에 5번째에 원소 하나를 삽입하라
4. 배열에 5번째 원소하나를 삭제하라
5. 5번째 배열을 조회하라
6. 위 5가지의 시간을 측정하라 (datetime 이용)

## 리스트
<img src="img/1_linked_list" />

### 리스트란?
* 자료들을 연속적으로 배열시키지는 않음, 기억공간(메모리)안의 임의의 위치에 저장시키되, 자료항목의 순서에따라 노드의 포인터 부분을 이용하여 서로 연결 시킨구조

### 리스트의 특징
* 삽입/삭제가 용이하다.
* 기억공간이 연속적이로 놓여있지 않아도 저장이 가능하다.
* 접근속도가 느리다.(포인터를 찾아가는 시간이 필요하기때문에 배열에비해 접그녹도가 느리다.)
* 중간 노드의연결이 끊어지면 다음 노드를 찾기 어렵다.
* 삽입/삭제시 O(1)의 시간복잡도, 조회시 O(n)의 시간복잡도

### 실습
1. 연결리스트를위한 노드를 하나 만들어라
2. 노드를 10개를 연결하여 연결리스트를 만들어라
3. 연결리스트의 5번째 원소하나를 삽입하라.
4. 연결리스트의 5번째 원소하나를 삭제하라
5. 5번째 배열을 조회하라
6. 위 5가지시간을 측정하고 배열과 시간을 비교하라

# 02. 스택 / 큐
## 스택
<img src="img/3_stack.png" />

### 스택이란?
* 스택의 의미가 '더미, 쌓아놓은'인것처럼, 가장 최근에 들어온 데이터가 가장 위에 있고 나중에 나가는 형식으로 저장하는 자료구조 (LIFO: Last In First Out)

### 스택의 특징
* 자료의 삽입, 삭제 작업이 한쪽 방향에서만 이루어지는 구조
* 나중에 삽입된 자료가 가장 먼저 삭제되는 방식으로 삭제되는 방식으로 처리
* TOP: 스택포인터라함, 스택으로 할장된 기억공간에 가장 마지막으로 삽입된 자료가 기억된 공간을 가리키는 요소

### 연산
* pop(): 스택에서 가장 위에있는 항목을 제거
* push(item): item하나를 스택의 가장 윗부분에 추가
* peek(): 스택의 가장 위에있는 항목 반환
* isEmpty(): 스택이 비어있을때 true 반환 

### 실습
1. 스택의 연산을 구현하라
2. 스택을 링크드리스트로 구현하라

### 관련문제
1. [스택](https://www.acmicpc.net/problem/10828)
2. [괄호](https://www.acmicpc.net/problem/9012)
3. [쇠막대기](https://www.acmicpc.net/problem/10799)
4. [제로](https://www.acmicpc.net/problem/10773)


## 큐
<img src="img/5_queue.png" />

### 큐란?
* 먼저 넣은 데이터가 먼저나오는 구조를가진 선입 선출구조로 저장하는 자료구조
### 큐의 특징
* 선형 리스트 한쪽에는 삽입, 다른한쪽에는 삭제 작업이 이루어지는 구성한 자료구조
* 시장과 끝을 표시하는 두개의 포인터가 있다.
* 창구업무처럼 순서를 기다리는 등의 대기 행렬에서 사용

### circular queue
<img src="img/circular_queue.png" />

* 선형큐의 문제점을 보안하기 위한 자료구조
* 선형큐의 rear 가 가리키는 포인터가 배열의 마지막 인덱스를 가리키고 있을때 앞쪽에서 remove연산으로 발생한 빈공간을 활용할 수 없음
* 포인터 증가방식이 (rear+1)%arraysize == front를 이용하여 데이터 삽입 가능

### 연산
* add(item): item을 리스트 끝부분에 추가
* remove(): 리스트 첫번째 항목 제거
* peek(): 큐에서 가장 위에있는 항목반환
* isEmpty(): 큐가 비었을때 true 반환

### 실습
1. queue를 구현하라
2. circular queue를 구현하라

### 관련문제
1. [큐](https://www.acmicpc.net/problem/10845)
2. [큐2](https://www.acmicpc.net/problem/18258) 
3. [카드](https://www.acmicpc.net/problem/2161)
4. [카드2](https://www.acmicpc.net/problem/2164)

# 03. 순환/덱
# 04. 트리
# 05. 우선순위큐
# 06. 정렬 
# 07. 그래프
# 08. 해싱
# 09. 탐색
# 10.순환

